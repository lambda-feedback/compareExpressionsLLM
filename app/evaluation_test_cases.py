from evaluation import Params, evaluation_function
from parameter import create_sympy_parsing_params
# [response, answer, params, expected]
test_cases = [
            ["2+2", "4", Params(), True], #1
            ["sin(x)**2 + cos(x)**2", "1", Params(), True],
            ["x+y", "y+x", Params(), True],
            ["x*y", "x+y", Params(), False],
            ["x**2 + 2*x + 1", "(x+1)**2", Params(), True],
            ["x**2 - 1", "(x-1)*(x+1)", Params(), True],
            ["x^5-1", "(x-1)*(x**4+x**3+x**2+x+1)", Params(), True],
            ["sin(x) + cos(x)", "cos(x) + sin(x)", Params(), True],
            ["sin(x) * cos(x)", "sin(x) + cos(x)", Params(), False],
            ["exp(x) * exp(y)", "exp(x+y)", Params(), True],
            ["log(x*y)", "log(x) + log(y)", Params(), False],
            ["x**3 + x**2", "x**2 * (x + 1)", Params(), True],
            ["", "", Params(), True],       
            ["", "x", Params(), False],
            ["1+", "1", Params(), False],
            ["x+1=0", "-2*x-2=0", Params(), True],
            ["dy/dx", "diff(y, x)", Params(), True],
            ["(x+y)/x", "1 + y/x", Params(), True],
            ["∫fdx", "int(f, x)", Params(), True],
            ["dy/dx + 1", "diff(y, x) + 1", Params(), True],
            ["dp/dt", "diff(p, t)", Params(), True],
            ["du/dx", "diff(y,x)", Params(), False],
            ["infty", "Infinity", Params(), True],
            ["sqrt(-1)", "I", Params(), True],
            ["sqrt(x**2)", "x", Params(), False],
            ["1/(x-1)", "1/(1-x)", Params(), False],
            ["x^2", "x**2", Params(), True],
            ["x^^2", "x**2", Params(), False],
            ["d^3y/dx^3", "diff(y, x, x, x)", Params(), True],
            ["∫∫fdxdy", "int(int(f, x), y)", Params(), True],
            ["f=x+1", "f-x-1=0", Params(), True],
            ["diff(y,x)+", "diff(y,x)+0", Params(), False],
            ["d/dx(y", "diff(y, x)", Params(), False],
            ["rho", "ρ", Params(), True],
            ["Drho/Dt=-div(u_vec)", "Drho/Dt+div(u_vec)=0", Params(), True],
            ["(1/rho)*Drho/Dt=-div(u_vec)", "(1/ρ)*Dρ/Dt+div(u_vec)=0", Params(), True],
            ["grad(u_r)=delu_r/delr*hat(r)+delu_r/deltheta*hat(theta)+delu_r/delz*hat(z)", "grad(u_r)=delu_r/delr*hat(r)+delu_r/deltheta*hat(theta)+delu_r/delz*hat(z)", Params(), True],
            ["Du_vec/Dt", "smart_derivative(u_vec,t) + dot(grad(u_vec),(u_vec))", Params(), True],
            ["u_vec", "u_vec", Params(), True],
            ["Gradient(u_vec)", "Gradient(u_vec)", Params(), True],
            ["u_vec.dot(x_vec)", "u_vec.dot(x_vec)", Params(), True],
            ]
        
test_cases2 = [
            ["abs(x)", "sqrt(x**2)", Params(), False],
            ["abs(x)", "sqrt(x**2)", Params(symbol_assumptions={"x": {"real": True},}), True],
            ["y - y(x)", "0", Params(), False], 
            ["y - y(x)", "0", Params(function=["y(x)"]), True], 
            ["diff(f*g, x)", "f*diff(g, x) + g*diff(f, x)", Params(function=["f(x)", "g(x)"]), True], 
            ["3", "3", Params(domain="(0,3]"), True],
            ["3", "3", Params(domain="(0,3)"), False],
            # ["0=∫_{V_sys}(delrho/delt+div(rho*u_vec))dV",
            # "0=Integral(smart_derivative(rho,t,1)+Divergence(rho*u_vec),V)",
            # {}, True],

            # ["∫_{V_sys}(∂rho/∂t+div(rho*u_vec))dV=0",
            # "Integral(smart_derivative(rho,t,1)+Divergence(rho*u_vec),V)=0",
            # {}, True],

            # ["∫_{V_sys}(∂rho/∂t+div(rho*u_vec))dV=0",
            # "Integral(smart_derivative(rho,t,1),V)=0",
            # {}, False],
            ]
